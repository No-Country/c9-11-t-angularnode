"use strict";
/* eslint-disable @typescript-eslint/ban-ts-comment */
// Keep in mind that this file is automatically generated.
// You can change the content of this file, but it will be overwritten.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractCondition = void 0;
const lodash_1 = __importDefault(require("lodash"));
const prisma_repo_1 = require("./prisma-repo");
const extractCondition = (conditions) => {
    const dbCond = lodash_1.default.isObject(conditions) ? conditions : { id: lodash_1.default.toNumber(conditions) };
    return dbCond;
};
exports.extractCondition = extractCondition;
/**
 * @param modelName - The model name
 */
const BaseRepository = (modelName) => {
    class AbstractBaseRepository {
        /**
         * Find zero or more `model` that matches the filter.\
         * Note, that providing `undefined` is treated as the value not being there.
         */
        static findAll(conditions, filterQueryParams = {}, query = {}, option = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                const limit = +(query.limit === 'all' ? 0 : lodash_1.default.get(query, 'limit', 10));
                const offset = query.page && query.page > 0 ? limit * (query.page - 1) : 0;
                const otherOptions = lodash_1.default.omit(query, ['limit', 'offset', 'page']);
                const where = Object.assign(Object.assign(Object.assign({}, (0, exports.extractCondition)(conditions)), filterQueryParams), otherOptions);
                return {
                    // @ts-ignore
                    rows: (yield AbstractBaseRepository.model.findMany(Object.assign(Object.assign(Object.assign({ 
                        // @ts-ignore
                        where }, option), { skip: offset }), (limit > 0 && { take: limit })))),
                    /* @ts-ignore */
                    count: yield this.count(where),
                };
            });
        }
        /**
         * Alternative of `findAll`.\
         * It works same as `findOne` but only have different names.\
         * It exists for anyone who prefer to use prisma `functions` original name.
         */
        static findMany(...params) {
            return __awaiter(this, void 0, void 0, function* () {
                return AbstractBaseRepository.findAll(...params);
            });
        }
        /**
         * Find the first `model` that matches the filter.\
         * Note, that providing `undefined` is treated as the value not being there.
         */
        static findOne(conditions, option = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                const where = (0, exports.extractCondition)(conditions);
                // @ts-ignore
                return AbstractBaseRepository.model.findFirst(Object.assign({ 
                    // @ts-ignore
                    where }, option));
            });
        }
        /**
         * Alternative of `findOne`.\
         * It works same as `findOne` but only have different names.\
         * It exists for anyone who prefer to use prisma `functions` original name.
         */
        static findFirst(...params) {
            return __awaiter(this, void 0, void 0, function* () {
                return AbstractBaseRepository.findOne(...params);
            });
        }
        /**
         * Find zero or one `model` that matches the filter.\
         * Note, that providing `undefined` is treated as the value not being there.\
         * It works same as `findOne` or `findFirst` but only accept a unique column.
         */
        static findUnique(conditions, option = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                const where = (0, exports.extractCondition)(conditions);
                // @ts-ignore
                return AbstractBaseRepository.model.findUnique(Object.assign({ 
                    // @ts-ignore
                    where }, option));
            });
        }
        /**
         * Create a `model`.
         */
        static create(data, option = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                // @ts-ignore
                return AbstractBaseRepository.model.create(Object.assign({ data }, option));
            });
        }
        /**
         * Update a `model`.
         */
        static update(conditions, data, option = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                const where = (0, exports.extractCondition)(conditions);
                // @ts-ignore
                return AbstractBaseRepository.model.update(Object.assign({ data,
                    // @ts-ignore
                    where }, option));
            });
        }
        /**
         * Delete any `model` that match with the conditions.
         */
        static delete(conditions) {
            return __awaiter(this, void 0, void 0, function* () {
                const where = (0, exports.extractCondition)(conditions);
                // @ts-ignore
                return AbstractBaseRepository.model.deleteMany({
                    // @ts-ignore
                    where,
                });
            });
        }
        /**
         * Delete a `model`.
         */
        static deleteOne(conditions) {
            return __awaiter(this, void 0, void 0, function* () {
                const where = (0, exports.extractCondition)(conditions);
                // @ts-ignore
                return AbstractBaseRepository.model.delete({
                    // @ts-ignore
                    where,
                });
            });
        }
        /**
         * Create or update one `model`.
         */
        static updateOrCreate(conditions, data, option = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                const obj = yield AbstractBaseRepository.findOne(conditions, option);
                if (obj)
                    return AbstractBaseRepository.update(conditions, data, option);
                return AbstractBaseRepository.create(data);
            });
        }
        /**
         * Alternative of `updateOrCreate`.\
         * It works same as `updateOrCreate` but only have different names.\
         * It exists for anyone who prefer to use prisma `functions` original name.
         */
        static upsert(...params) {
            return __awaiter(this, void 0, void 0, function* () {
                return AbstractBaseRepository.updateOrCreate(...params);
            });
        }
        /**
         * Create many `model`.
         */
        static bulkCreate(data, skipDuplicates = true) {
            return __awaiter(this, void 0, void 0, function* () {
                // @ts-ignore
                return AbstractBaseRepository.model.createMany({
                    data,
                    // @ts-ignore
                    skipDuplicates,
                });
            });
        }
        /**
         * Alternative of `bulkCreate`.\
         * It works same as `bulkCreate` but only have different names.\
         * It exists for anyone who prefer to use prisma `functions` original name.
         */
        static createMany(...params) {
            return __awaiter(this, void 0, void 0, function* () {
                return AbstractBaseRepository.bulkCreate(...params);
            });
        }
        /**
         * Update zero or more `model`.
         * Note, that providing `undefined` is treated as the value not being there.
         */
        static bulkUpdate(where, data) {
            return __awaiter(this, void 0, void 0, function* () {
                // @ts-ignore
                return AbstractBaseRepository.model.updateMany({
                    data,
                    where,
                });
            });
        }
        /**
         * Alternative of `bulkUpdate`.\
         * It works same as `bulkUpdate` but only have different names.\
         * It exists for anyone who prefer to use prisma `functions` original name.
         */
        static updateMany(...params) {
            return __awaiter(this, void 0, void 0, function* () {
                return AbstractBaseRepository.bulkUpdate(...params);
            });
        }
        /**
         * Count the number of `model`.\
         * Note, that providing `undefined` is treated as the value not being there.
         */
        static count(conditions, option = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                const where = (0, exports.extractCondition)(conditions);
                // @ts-ignore
                return AbstractBaseRepository.model.count(Object.assign({ 
                    // @ts-ignore
                    where }, option));
            });
        }
        static groupBy(conditions, aggregator) {
            return __awaiter(this, void 0, void 0, function* () {
                const where = (0, exports.extractCondition)(conditions);
                // @ts-ignore
                return AbstractBaseRepository.model.groupBy(Object.assign({ 
                    // @ts-ignore
                    where }, aggregator));
            });
        }
        /**
         * Allows you to perform aggregations operations on a `model`.\
         * Note, that providing `undefined` is treated as the value not being there.\
         * If no any kind of aggregator provided, will use `count` by default.
         */
        static aggregate(conditions, aggregator, option = {}) {
            // @ts-ignore
            const aggregate = AbstractBaseRepository.model.aggregate;
            const where = (0, exports.extractCondition)(conditions);
            if (lodash_1.default.isEmpty(aggregator)) {
                // @ts-ignore
                // eslint-disable-next-line no-param-reassign, no-underscore-dangle
                aggregator._count = true;
            }
            // @ts-ignore
            return aggregate(Object.assign(Object.assign({ 
                // @ts-ignore
                where }, aggregator), option));
        }
        static get model() {
            // @ts-ignore
            return prisma_repo_1.models[AbstractBaseRepository.modelName];
        }
    }
    AbstractBaseRepository.modelName = modelName;
    return AbstractBaseRepository;
};
exports.default = BaseRepository;
//# sourceMappingURL=baseRepository.js.map